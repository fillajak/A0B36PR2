/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package chebot.logic.Pieces;

import chebot.logic.Board;
import chebot.logic.DigVec;
import chebot.logic.LogicException;
import chebot.logic.Position;
import chebot.logic.PositionList;
import chebot.logic.enums.Side;
import chebot.logic.enums.Type;
import java.util.LinkedList;
import javax.swing.border.Border;



/**
 *Represents one pieceon board. Has referece to board.
 * @author Dick
 */
public abstract class Piece {
    protected Side side;
    protected Position position;
    protected Board board;
    protected boolean out;
    protected LinkedList<DigVec> simpleMoves = new LinkedList<>();
    protected boolean moved;

    public Piece(Side side, Position position, Board board) {
        this.side = side;
        this.position = position;
        this.board = board;
        this.out = false;
        this.moved = false;
    }
/**
 * Generates list of positions on which can this piece move. This method dont check board for unwanted situations.
 * @return unchecked positions to move
 */
    protected abstract PositionList getPositionsToMoveUnchecked();
    /**
     * Generates list of position, which can be taken (or give check) by this piece.
     * @return positions
     */
    protected PositionList getPositionsToCheck(){
        return getPositionsToMoveUnchecked();
    }
/**
 * Gets result of getPositionsToMove() and delete moves, that would endanger king of same side.
 * @return checked positions to move
 */
    public PositionList positionsToMove(){
        PositionList positions = getPositionsToMoveUnchecked();
        PositionList valid = new PositionList();
        for (Position p: positions.getList()){
            Move m = new Move(position, p, board);
            m.execute();
            if (!board.getPieceList().hasCheck(side)){
                valid.add(p);
            }
            m.reverse();
        }
        
        return valid;
    }
    public Position getPosition() {
        return position;
    }

    
/**
 * Generates available postions, where can selected piece move. 
 * Moves generated by this method must be check before actual move.
 * - check positionsToMove()
 * @return - positions 
 */
    protected final PositionList go() {
        Position next;
        Piece piece;
        PositionList res = new PositionList();
        for (DigVec d : simpleMoves) {
            next = position.clone();
            while (true) {
                try {
                    next = next.getNextMove(d);
                    piece = board.getPieceList().getByPosition(next);
                    if (piece.side == this.side){
                        break;
                    }
                    if (piece.side != this.side){
                        res.add(next);
                        break;
                    }
                } catch (LogicException ex) {
                    if (ex.getCode() == LogicException.OUT_OF_FIELD_CODE) {
                        break;
                    }
                    if (ex.getCode() == LogicException.NO_PIECE_FOUND){
                       res.add(next);
                    }
                }
                if (d.getType() == Type.JUMP){
                    break;
                }
            }

        }
        return res;

    }

    @Override
    public final String toString() {
        return side+this.getClass().getSimpleName() +position;
    }

    public Side getSide() {
        return side;
    }
    
}
