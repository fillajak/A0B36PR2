/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package chebot.logic.piece;

import chebot.logic.move.MoveList;
import chebot.logic.Board;
import chebot.logic.DigVec;
import chebot.logic.LogicException;
import chebot.logic.Position;
import chebot.logic.PositionList;
import chebot.logic.enums.Side;
import chebot.logic.enums.Type;
import java.util.LinkedList;

/**
 * Represents one pieceon board. Has referece to board.
 *
 * @author Dick
 */
public abstract class Piece {

    protected Side side;
    protected Position position;
    protected Board board;
    protected boolean out;
    protected LinkedList<DigVec> simpleMoves = new LinkedList<>();
    protected boolean moved;
    protected LinkedList<Position> history = new LinkedList<>();

    public Piece(Side side, Position position, Board board) {
        this.side = side;
        this.position = position;
        this.board = board;
        this.out = false;
        this.moved = false;
        this.history.add(position);
    }

   public Board getBoard(){
       return this.board;
   }
    public boolean isOut() {
        return out;
    }
    public void setOut(boolean out){
        this.out = out;
    }
    /**
     * Changes position of this piece, this method dont check validity of this move. Dont kick other pieces.
     * @param position 
     */
    public void move(Position position) {
        history.add(this.position.clone());
        this.position.changePosition(position);
        moved = true;
    }

    /**
     * Undo last move made by this piece. Unchecked!
     */
    public void undoLastMove() {
        if (history.size() == 1) {
            moved = false;
            throw new LogicException("cant undo", -1);
        } else {
            if (history.size() == 2) {
                moved = false;
            }
            position.changePosition(history.removeLast());
        }
       
    }
/**
 * Gets position history
 * @return positions
 */
    public LinkedList<Position> getHistory() {
        return history;
    }

    public void setHistory(LinkedList<Position> history) {
        this.history = history;
    }

   
    /**
     * Generates list of positions on which can this piece move. This method dont check board for unwanted situations.
     * @return unchecked positions to move
     */
    public abstract PositionList getPositionsToMoveUnchecked();

    /**
     * Generates list of position, which can be taken (or give check) by this
     * piece.
     *
     * @return positions
     */
    protected PositionList getPositionsToCheck() {
        return getPositionsToMoveUnchecked();
    }

    public Position getPosition() {
        return position;
    }
    /**
     * Generates available postions, where can selected piece move. Moves
     * generated by this method must be check before actual move. 
     * @return - positions
     */
    protected final PositionList go() {
        Position next;
        Piece piece;
        PositionList res = new PositionList();
        for (DigVec d : simpleMoves) {
            next = position.clone();
            while (true) {
                try {
                    next = next.getNextMove(d);
                    piece = board.getPieceList().getByPosition(next);
                    if (piece.side == this.side) {
                        break;
                    }
                    if (piece.side != this.side) {
                        res.add(next);
                        break;
                    }
                } catch (LogicException ex) {
                    if (ex.getCode() == LogicException.OUT_OF_FIELD_CODE) {
                        break;
                    }
                    if (ex.getCode() == LogicException.NO_PIECE_FOUND) {
                        res.add(next);
                    }
                }
                if (d.getType() == Type.JUMP) {
                    break;
                }
            }

        }
        return res;

    }

    @Override
    public final String toString() {
        return getTag() + position;
    }

    public String getTag() {
        String shrt;
        if (this instanceof Knight) {
            shrt = "N";
        } else {
            shrt = this.getClass().getSimpleName().charAt(0) + "";
        }
        return side.getShrt() + shrt;
    }

    public Side getSide() {
        return side;
    }
    /**
     * Returns list of checked moves, which can be executed later. Takes unchecked moves and check them.
     * @return available moves
     */
    public MoveList getMoves() {
        MoveList mlist = new MoveList(this);
        return mlist;
    }

    public boolean isMoved() {
        return moved;
    }

    public void setMoved(boolean moved) {
        this.moved = moved;
    }
    
}
